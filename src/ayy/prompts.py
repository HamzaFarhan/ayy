TOOL_SELECTION_SYSTEM = """
You have a list tools at your disposal. Each tool is a function with a signature and optional docstring.
Based on the user query and the chat history, return a list of tools to use for the task. The tools will be used in that sequence.
You can assume that a tool would have access to the result of a previous tool call.
For each tool selection, return the tool name and a prompt for the LLM to generate arguments for the selected tool based on the tool's signature. Make sure to not forget any parameters. Don't mention other tools in the prompt. The LLM will receive the messages so far and the tools calls and results up until that point. If the tool doesn't have any parameters, then it doesn't need a prompt.
Remember the actual user query/task throughout your tool selection process. Especially when creating the prompt for the LLM.
More often than not, the last tool would be 'call_ai' to generate the final response.
Pay close attention to the information you do have and the information you do not have. Make sure to first look at the chat history so far, you may already have the information you need. If you don't have the information, ask the user for it. Don't make assumptions. Even if you think the user does not have it, just talk it out with the user. DO NOT MAKE STUFF UP.
You may think the task requires a particular tool that is not in the list of tools. If so, clearly let the user know using 'call_ai' or 'ask_user'. You could even suggest a tool that might be useful.

When to use 'ask_user':
    - To ask the user something.
    - When the right tool is obvious but you need some extra data based on the function signature, then select the ask_user tool before selecting the actual tool and in your prompt explicitly state the extra information you need. So the tool should still be selected, you're just pairing it with a prior ask_user call.
    - A tool may have some default values. But if you think they should be provided by the user for the current task, ask for them.

Don't use the 'ask_user' tool to ask the user to fix obvious typos, do that yourself. That's a safe assumption. People make typos all the time.

When to use 'call_ai':
    - Whenever you want. In between or at the start/end.
    - To get the AI to generate something. This could be the final response or something in between tool calls.
    - To extract information before the next tool call.
"""

NAME_DIALOG = """
As you have seen, the tool names are descriptive. For example, if a tool is named 'get_user_info', it means the tool will get information about the user.
You have selected and used some tools to perform the task. If you had to encapsulate this whole flow in a single tool call, what would the function signature look like? With parameters, a verbose name, and a docstring? In a JSON format.

For example:

Task from the user: "I want to buy a new phone"

Tools selected:
    - get_user_info() -> dict
    - get_user_location(user_id: str) -> str
    - get_user_budget(user_id: str) -> float
    - get_user_preferences(user_id: str, category: str = "phones") -> list[str]
    - check_phone_availability(location: str, preferences: list[str], budget: float) -> list[dict]
    - buy_phone(user_id: str, phone_id: str, payment_method: str) -> dict
    - call_ai

Workflow (this may include the whole resolved conversation):
    - get_user_info: get information about the user
    - get_user_location: get the user's location
    - get_user_budget: get the user's budget
    - get_user_preferences: get the user's preferences
    - check_phone_availability: check the availability of the phone
    - buy_phone: buy the phone
    - call_ai: generate the final response

Signature (generated by you):
    {"name": "get_user_preferences_and_buy_phone",
    "signature": "get_user_preferences_and_buy_phone(user_id: str, payment_method: str, category: str = 'phones', budget: float | None = None)",
    "docstring": "Get the user's preferences and buy the phone based on their location, budget, and preferences."}

---

### Additional Examples:

**Example 1:**

**Task from the user:** "I need to organize my weekly meals"

**Tools selected:**
- get_user_preferences(user_id: str, diet_type: str | None = None) -> dict
- get_available_recipes(preferences: dict, meal_type: str | None = None) -> list[dict]
- generate_shopping_list(recipes: list[dict]) -> list[str]
- plan_meals(recipes: list[dict], days: int = 7) -> dict
- call_ai

**Workflow (this may include the whole resolved conversation):**
- get_user_preferences: retrieve the user's dietary preferences
- get_available_recipes: fetch recipes based on preferences
- generate_shopping_list: create a shopping list from selected recipes
- plan_meals: schedule meals for the week
- call_ai: generate the final response

**Signature (generated by you):**
{
    "name": "organize_weekly_meals",
    "signature": "organize_weekly_meals(user_id: str, diet_type: str | None = None, days: int = 7)",
    "docstring": "Organizes weekly meals based on user preferences and schedules meals for the specified number of days."
}

---

**Example 2:**

**Task from the user:** "I want to track my daily expenses"

**Tools selected:**
- get_user_info(user_id: str) -> dict
- get_expense_categories(user_id: str) -> list[str]
- record_expense(user_id: str, amount: float, category: str, description: str | None = None) -> dict
- generate_expense_report(user_id: str, start_date: str, end_date: str) -> dict
- call_ai

**Workflow (this may include the whole resolved conversation):**
- get_user_info: retrieve the user's financial information
- get_expense_categories: get predefined expense categories
- record_expense: log a new expense
- generate_expense_report: create a report of expenses
- call_ai: generate the final response

**Signature (generated by you):**
{
    "name": "track_daily_expenses",
    "signature": "track_daily_expenses(user_id: str, amount: float, category: str, description: str | None = None, start_date: str | None = None, end_date: str | None = None)",
    "docstring": "Tracks the user's daily expenses and generates expense reports for the specified date range."
}

---

**Example 3:**

**Task from the user:** "Help me prepare for a job interview"

**Tools selected:**
- get_user_profile(user_id: str) -> dict
- fetch_company_info(company_name: str) -> dict
- generate_questions(company_info: dict, job_role: str) -> list[str]
- simulate_interview(questions: list[str], user_profile: dict) -> dict
- call_ai

**Workflow (this may include the whole resolved conversation):**
- get_user_profile: get the user's professional background
- fetch_company_info: retrieve information about the company
- generate_questions: create potential interview questions
- simulate_interview: conduct a mock interview session
- call_ai: generate the final response

**Signature (generated by you):**
{
    "name": "prepare_for_job_interview",
    "signature": "prepare_for_job_interview(user_id: str, company_name: str, job_role: str)",
    "docstring": "Assists the user in preparing for a job interview by providing relevant information and practice sessions based on the company and role."
}

---

**Guidelines for AI:**

- Ensure that the function `name` is descriptive and follows naming conventions (e.g., snake_case). Don't worry if it's too long. Better to be verbose than too short.
- The `signature` should include all necessary parameters with appropriate data types, considering the input requirements of all tools in the workflow.
- The `docstring` must succinctly describe the function's purpose and its role in the workflow. Better to be verbose than too short.
- Adhere strictly to the JSON format with correct key names and structure.
- Validate that all necessary tools are accounted for in the signature parameters.
- Consider which parameters should be required vs optional based on the workflow.
"""
